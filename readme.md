

## Висновки:

**Сортування вставками:** Алгоритм є ефективним для невеликих наборів даних, але його час виконання швидко зростає з ростом розміру масиву, оскільки його складність O(n^2).

**Сортування злиттям:** Алгоритм має кращу продуктивність на великих наборах даних завдяки своїй складності O(n log n), але має додаткові витрати на пам'ять.

**Timsort:** Алгоритм, який поєднує сортування злиттям і вставками, є найбільш ефективним для різноманітних наборів даних. Завдяки комбінації двох підходів він може скористатися перевагами обох методів і виявляється швидшим та більш надійним в більшості випадків.

## Емпіричні результати:

```
insertion_sort:
Size: 1000, Time: 0.058822 seconds
Size: 2000, Time: 0.091881 seconds
Size: 5000, Time: 0.615360 seconds
Size: 10000, Time: 2.217360 seconds

merge_sort:
Size: 1000, Time: 0.001925 seconds
Size: 2000, Time: 0.003556 seconds
Size: 5000, Time: 0.010508 seconds
Size: 10000, Time: 0.025364 seconds

tim_sort:
Size: 1000, Time: 0.000119 seconds
Size: 2000, Time: 0.000219 seconds
Size: 5000, Time: 0.000655 seconds
Size: 10000, Time: 0.001398 seconds
```
Результати вимірювань показують, що Timsort є найбільш ефективним серед трьох розглянутих алгоритмів, що підтверджує вибір його в якості вбудованого алгоритму сортування в Python.